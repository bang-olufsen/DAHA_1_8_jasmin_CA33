/*
 * Copyright (c) 2020-2022 Analog Devices, Inc. All Rights Reserved.
 * This software is proprietary to Analog Devices, Inc. and its licensors.
 */

/** @addtogroup Init_Preload_SC59x Processor Initialization Code
 *  @{
 *
 *            This program is used to generate both Initialization and Preload codes.
 *
 *            The Preload executable is used as part of debugging via CCES, to initialize CGU and DMC
 *            (clocks and DDR controller) before downloading and debugging the actual application.
 *
 *            The Initialization executable (Init block) is used as part of the Boot process to initialize above blocks
 *            before booting the rest of the application. Additionally, macros are provided in order to reinitialize
 *            the clocks to assist in efficiently reducing the overall boot time. This includes the following:
 *            - UART Slave boot: Once CGU is initialized the UART Baud rate would need to be recalculated and reinitialized.
 *            - SPI Master boot: SPI clock rate can be reinitialized as desired.
 *            - OSPI Master boot: OSPI clock rate can be reinitialized as desired.
 *
 *           The project has dependency on certain macros to enable functionality for above cases.
 *
 *           Common macros:
 *
 *           - #CLKIN - Provide the CLKIN value used in the system. This is used for baud rate calculations.
 *           - #CONFIG_DMC0 - Define as 0, if there is no DDR on the board or the chip.
 *                            If this macro is defined as 0, then SMPU driver is invoked to prevent further access.
 *                            If this macro is defined as a non-zero value, then DDR Controller registers are configured by adi_dmc_cfg0_init().
 *           - #CONFIG_SPIFLASH - Define as 0, if there is no SPI Flash on the board or the chip.
 *                            If this macro is defined as 0, then SMPU driver is invoked to prevent further access.
 *           - #DO_PROCESS_BOOTSTRUCT - Define as 1, if there is need to process the boot struct passed by ROM.
 *                            If this macro is defined as 1, then the software can process the boot struct parameters.
 *                            No example is provided by default, user can consult Hardware Reference Manual.
 *           - #EXECUTE_SAFE_STATE - Define as 1, if the program must go in to a safe state up on errors in the API calls
 *                            If this macro is defined as 1, then the program would go in to safe state up on error
 *                            detection from the configuration APIs called earlier. By default an infinite loop is implemented.
 *           - #INIT_CANFD - Define to 1 to initialize RAM for CANFD peripherals.
 *           - #INIT_EMSI - Define to 1 to perform EMSI boot initializations.
 *
 *           Boot related macros for the init code:
 *           - #CONFIG_BOOT_UART_BAUD_RATE - Define as 1, if the UART Baud Rate need to be recalculated and reinitialized
 *                                           This is applicable only for UART Slave booting.
 *           - #CONFIG_BOOT_SPI_CLOCK_RATE - Define as 1, if the SPI Clock Rate need to be recalculated and reinitialized
 *                                           This is applicable only for SPI Master booting.
 *           - #CONFIG_BOOT_OSPI_CLOCK_RATE- Define as 1, if the OSPI Clock Rate need to be recalculated and reinitialized
 *                                           This is applicable only for OSPI Master booting.
 *           - #CONFIG_BOOT_SPI_CLOCK_VAL  - Macro for the new SPI Clock rate value
 *           - #CONFIG_BOOT_OSPI_CLOCK_VAL - Macro for the new OSPI Clock rate value
 *           - #CONFIG_BOOT_OSPI_READCAPDELAY - Macro for the OSPI Read Cap Delay value
 *
 *           If the clock frequencies must be changed, the CCES CGU Plugin can be used.
 *           adi_pwr_SC59x_config.c file is similar to the template output file generated by this plugin.
 *           This file can be replaced with the new configuration file. Consult the documentation of the
 *           plugin for new information. Consult adi_pwr_SC59x_config.c file for the default CGU settings used.
 *
 *           If the DMC settings must be changed the CCES DMC Plugin can be used.
 *           adi_dmc_SC59x_config.c file is similar to the template output file generated by this plugin.
 *           This file can be replaced with the new configuration file. Consult the documentation of the
 *           plugin for new information. Consult adi_dmc_SC59x_config.c file for the default DMC settings used.
 *
 *           Consult the readme.txt file for more information on building the project for Init code and Preload code.
 */


/*!
* @file      SC59x_InitPreload_code.c
*
* @brief     Initialization and Preload code for SC59x series of processors.
*
* @details
*            Initialization and Preload code for SC59x series of processors.
*/

#include "SC59x_InitPreload_code.h"

/* CLKIN must be defined so confirm it is. */
#if !defined(CLKIN)
  #error CLKIN macro define is required - add it to config.h
#endif

/* Confirm that macros for SPI/OSPI Clock Rate configuration are defined when necessary. */
#if defined(CONFIG_BOOT_SPI_CLOCK_RATE) && CONFIG_BOOT_SPI_CLOCK_RATE==1 && \
    !defined(CONFIG_BOOT_SPI_CLOCK_VAL)
  #error CONFIG_BOOT_SPI_CLOCK_VAL needs to be defined to the SPI clock rate value.
#endif

#if defined(CONFIG_BOOT_OSPI_CLOCK_RATE) && CONFIG_BOOT_OSPI_CLOCK_RATE==1
  #if !defined(CONFIG_BOOT_OSPI_CLOCK_VAL)
    #error CONFIG_BOOT_OSPI_CLOCK_VAL needs to be defined to the OSPI clock rate value.
  #endif
  #if !defined(CONFIG_BOOT_OSPI_READCAPDELAY)
    #error CONFIG_BOOT_OSPI_READCAPDELAY needs to be defined to the OSPI Read Cap Delay value
  #endif
#endif

#ifdef _MISRA_RULES
#pragma diag(suppress:misra_rule_16_7:"initcode pointer parameter is non-const")
#pragma diag(suppress:misra_rule_8_10:"initcode() and error variables are intentionally not static")

#endif

#if defined(__ADSPARM__)

#include <runtime/cache/adi_cache.h>
#include <runtime/mmu/adi_mmu.h>
#include <stdint.h>

#if defined(__ADSPCORTEXA5__)
void disable_mmu(void);
#endif

/* Set the global control variable adi_cache_gEnable to 0 so the cache runtime
 * support does not enable either of the L1 or L2 caches. This is done so that
 * emulator doesn't attempt to invalidate caches while loading the application
 * as doing so increases load times considerably.
 */
uint32_t adi_cache_gEnable = 0uL;

/* Define a stub adi_cache_Init function to replace the default one
 * to ensure caches aren't enabled and to avoid cache support functions
 * being linked in unnecessarily.
 */
ADI_CACHE_RESULT adi_cache_Init(void)
{
        return ADI_CACHE_SUCCESS;
}

#if defined(__ADSPCORTEXA55__)
/* Define a stub adi_mmu_Init function to replace the default one. */
ADI_MMU_RESULT adi_mmu_Init(void)
{
       return ADI_MMU_SUCCESS;
}
#endif /*__ADSPCORTEXA55__ */

#endif /* __ADSPARM__ */

#if CONFIG_BOOT_UART_BAUD_RATE || CONFIG_BOOT_SPI_CLOCK_RATE || \
    CONFIG_BOOT_OSPI_CLOCK_RATE || INIT_EMSI
static int32_t bcmd_device(ADI_ROM_BOOT_CONFIG* pBootStruct);
#endif
static void CheckResult(uint32_t result, const uint32_t lineErrPos);
static void ExecuteSafecode(void);
static void ExecuteIdle(void);

#if DO_PROCESS_BOOTSTRUCT
static uint32_t Processbootstruct(ADI_ROM_BOOT_CONFIG* pBootStruct);
#endif

/*
 * \var bool bError
 */
bool bError = false;

/*
 * \var unsigned int lastErrLinePos
 */
uint32_t lastErrLinePos = 0UL;

/*
 * \var unsigned int errCount
 */
uint32_t errCount = 0UL;

/**
 * @brief       The preload main() for SC59x series of processors.
 * @details     The preload main() for SC59x series of processors used when
 *              debugging. Not used for booting.
 *
 * @param[in]   NULL
 *
 * @return      NULL
 *
 * @sa          adi_pwr_Init()
 *              adi_pwr_cfg0_init()
 *              adi_uart_baud_read()
 *              adi_dmc_lane_reset()
 *              adi_dmc_cfg0_init()
 *              adi_uart_baud_init()
 *              adi_spi_clock_rate()
 *              adi_ospi_clock_rate()
 *              adi_smpu_cfg0_init()
 **/
#if defined (PRELOAD_CODE)
int main(int argc, char *argv[])
{
    /* Initialize components*/
    adi_initComponents();

    /* Initialize Init code. We don't process boot struct in preload case*/
    initcode(NULL);

#if defined(__ADSPCORTEXA5__)
    /* Disable the MMU and cache before returning control to the emulator */
    disable_mmu();
#endif

#if defined(__ADSPSC598_FAMILY__)
    /* Set the Internal Clock Enable and PLL enable bits on the eMSI clock
     * control register so that EMSI registers can be read when debugging.
     */

    *pREG_EMSI0_CLK_CTL |= BITM_EMSI_CLK_CTL_INTERNAL_CLK_EN;

    /* Wait For Clock Synchronization */
    while ((*pREG_EMSI0_CLK_CTL & BITM_EMSI_CLK_CTL_INTERNAL_CLK_STABLE) == 0u) {
    }

    *pREG_EMSI0_CLK_CTL |= BITM_EMSI_CLK_CTL_PLL_EN;

    /* Wait For Clock Synchronization */
    while ((*pREG_EMSI0_CLK_CTL & BITM_EMSI_CLK_CTL_INTERNAL_CLK_STABLE) == 0u) {
    }
#endif

#if (__NUM_ARM_CORES__==1) && defined(__ADSPSHARC__)
    /* Usually the preload runs on the ARM core for ADSP-SC5xx parts. For
     * the unusual case of debugging ADSP-SC5XX parts without access to
     * the ARM core we need a SHARC preload that sets the RCU message bits
     * to avoid stalling in the SHARC CRT startup waitloop.
     */
    *pREG_RCU0_MSG |= (BITM_RCU_MSG_C1ACTIVATE|BITM_RCU_MSG_C2ACTIVATE);
#endif

    return 0;
}
#endif

/**
 * @brief       Initialization and Preload code for SC59x series of processors.
 * @details     Initialization and Preload code for SC59x series of processors.
 *              When Preload code is built, this function is called by the main()
 *              When Init code is built, this function is directly called by the BOOT ROM
 *
 * @param[in]   pBootStruct Pointer to ADI_ROM_BOOT_CONFIG to process boot structure parameters
 *
 * @return      NULL
 **/

#if defined __ADSPSHARC__
#pragma retain_name /* retain resolved initcode entry */
#endif
uint32_t initcode(ADI_ROM_BOOT_CONFIG* pBootStruct)
{
    uint32_t result = 0UL;
#if CONFIG_BOOT_UART_BAUD_RATE
    uint32_t UART_Baud_Rate_Val = 0UL;
#endif
#if CONFIG_BOOT_UART_BAUD_RATE || CONFIG_BOOT_SPI_CLOCK_RATE || \
    CONFIG_BOOT_OSPI_CLOCK_RATE || INIT_EMSI
    int32_t boot_cmd_device = bcmd_device(pBootStruct);
#endif
#if CONFIG_DMC0
    bool bDMC0 = true;
#else
    bool bDMC0 = false;
#endif
#if CONFIG_SPIFLASH
    bool bSPIflash = true;
#else
    bool bSPIflash  = false;
#endif

#if INIT_EMSI /* Do not change the clock until all the data is received */
    if (boot_cmd_device == ENUM_ROM_BCMD_DEVICE_EMSI)
    {
        while ((*pREG_EMSI0_PSTATE & BITM_EMSI_PSTATE_DAT_LINE_ACTIVE) != 0u)
        {
            /*Wait for D0 line to get clear*/
        }
    }
#endif

    /*Initialize Power Service*/
    result = (uint32_t)adi_pwr_Init((uint8_t)ADI_PWR_CGU0, (uint32_t)CLKIN);
    CheckResult(result, (uint32_t) __LINE__);

#if CONFIG_BOOT_UART_BAUD_RATE
    /* Read UART Baud Rate*/
    UART_Baud_Rate_Val = adi_uart_baud_read(boot_cmd_device);
    result = (UART_Baud_Rate_Val == 0UL) ? 1UL : 0UL;
    CheckResult(result, (uint32_t) __LINE__);
    /* Now implement a 2 Byte delay before changing the clocks */
    result = adi_uart_byte_delay(boot_cmd_device);
    CheckResult(result, (uint32_t) __LINE__);
#endif

#if CONFIG_DMC0
    /* Set DMC Lane Reset */
    adi_dmc_lane_reset(true);
#endif

    /* Initialize CGU and CDU */
    result = (uint32_t)adi_pwr_cfg0_init();
    CheckResult(result, (uint32_t) __LINE__);

#if CONFIG_DMC0
    /* Clear DMC Lane Reset */
    adi_dmc_lane_reset(false);

    /* Initialize DMC */
    result = adi_dmc_cfg0_init();
    CheckResult(result, (uint32_t) __LINE__);

#if defined(__ADSPSC598_FAMILY__) && defined(__ADSPARM__)
    /* DDR workaround.
    ** Restricts the outstanding transactions to 1 for both read/write
    ** to force in-order access/response from A55 to/from DDR.
    */
    *pREG_SCB6_A55_M0_IB_FN_MOD = 3u; /* SCB6 A55 M0 Ib.fn Mod */
    asm volatile("isb");
#endif
#endif

    /* Initialize SMPU to restrict access on unpopulated memories */
    result = adi_smpu_cfg0_init(bDMC0, bSPIflash);
    CheckResult(result, (uint32_t) __LINE__);

#if CONFIG_BOOT_UART_BAUD_RATE
    /* Reinitialize UART Baud Rate */
    result = adi_uart_baud_init(boot_cmd_device, UART_Baud_Rate_Val);
    CheckResult(result, (uint32_t) __LINE__);
#endif

#if CONFIG_BOOT_SPI_CLOCK_RATE
    /* Reinitialize SPI Clock Rate */
    result = adi_spi_clock_rate(boot_cmd_device, (uint32_t)CONFIG_BOOT_SPI_CLOCK_VAL);
    CheckResult(result, (uint32_t) __LINE__);
#endif

#if CONFIG_BOOT_OSPI_CLOCK_RATE
    /* Reinitialize SPI Clock Rate */
    result = adi_ospi_clock_rate(boot_cmd_device, (uint32_t)CONFIG_BOOT_OSPI_CLOCK_VAL, (uint8_t)CONFIG_BOOT_OSPI_READCAPDELAY);
    CheckResult(result, (uint32_t) __LINE__);
#endif

#if defined(__ADSPSC598_FAMILY__)
    /* Take EMAC0 (RGMII) out of reset. */
    *pREG_PADS0_PCFG0 |= BITM_PADS_PCFG0_EMACRESET;
#endif

#if INIT_CANFD
    adi_canfd_init();
#endif

#if INIT_EMSI
    if (boot_cmd_device == ENUM_ROM_BCMD_DEVICE_EMSI)
    {
        pBootStruct->dBootCommand &= ~BITM_ROM_BCMD_EMSI_SAFEBOOT;
        result = adi_emsi_init();
        CheckResult(result, (uint32_t) __LINE__);
    }
#endif

#if DO_PROCESS_BOOTSTRUCT
    if(pBootStruct != NULL)
    {
        result = Processbootstruct(pBootStruct);
        CheckResult(result, (uint32_t) __LINE__);
    }
#endif

    return 0u;
}

#if CONFIG_BOOT_UART_BAUD_RATE || CONFIG_BOOT_SPI_CLOCK_RATE || \
    CONFIG_BOOT_OSPI_CLOCK_RATE || INIT_EMSI
/*
 * Return the bcmd field bits of the boot structure dBootCommand.
 */
static int32_t bcmd_device(ADI_ROM_BOOT_CONFIG* pBootStruct)
{
    int32_t bcmd = ENUM_ROM_BCMD_DEVICE_NONE;
    if (pBootStruct != NULL)
    {
        bcmd = pBootStruct->dBootCommand;
        uint32_t bcmd_bits = (uint32_t) bcmd & BITM_ROM_BCMD_DEVICE;
        bcmd = (int32_t) bcmd_bits;
    }
    return bcmd;
}
#endif

/*
 * Note errors if result code is not success.
 */
static void CheckResult(uint32_t result, const uint32_t lineErrPos)
{
    if(result != 0u)
    {
        bError = true;
        errCount++;
        lastErrLinePos = lineErrPos;

    #if EXECUTE_SAFE_STATE
        ExecuteSafecode();
    #endif
    }
}

/*
 * Execute a safe code if errors are detected.
 */
static void ExecuteSafecode()
{
    while(1)
    {
        ExecuteIdle();
    }
}

static void ExecuteIdle()
{
#if defined __ADSPARM__
  __asm__("WFI");
#elif defined __ADSPSHARC__
    asm("idle;");
#endif
}

#if DO_PROCESS_BOOTSTRUCT
static uint32_t Processbootstruct(ADI_ROM_BOOT_CONFIG* pBootStruct)
{
    /*
     * Process the boot structure as required here. By default, the structure is not processed.
     * Refer to Hardware Reference Manual for more information on boot structures.
     * Refer to ADI_ROM_BOOT_CONFIG definition for the structure type passed.
     */

    return 0u;
}
#endif

/*@}*/
